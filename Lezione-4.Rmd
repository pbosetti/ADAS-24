---
title: "Lezione 4: Bootstrap"
author: "Paolo Bosetti"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    number_sections: true
  html_notebook:
    toc: true
  word_document:
    toc: true
  html_document:
    toc: true
header-includes: \usepackage[italian]{babel}
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(modelr)
library(boot)
source("my_lib.R")

knitr::opts_chunk$set(
  fig.dim=c(5,3),      # dimensioni delle figure in pollici
  out.width = "10cm",  # larghezza figure sul documento
  fig.align = "center"
) 
```

# Bootstrap non-parametrico

Calcoliamo l'intervallo di confidenza per la media campionaria di un singolo campione (equivalente di un T-test a un campione a due lati).

Creiamo una tabella di dati e utilizziamo la funzione `boot()` per calcolare i **campioni di bootstrap**, cioè le $R$ repliche del calcolo della statistica di interesse (media) su altrettanti campioni ottenuti dal campione di partenza mediante ricampionamento con reinserimento.

Si noti che l'argomento `statistic` di `boot()` deve essere una funzione con due argomenti: al primo viene passato il vettore dei dati originali; al secondo argomento viene passato, di volta in volta e per `R` volte, il vettore degli indici corrispondenti a ciascun campione di bootstrap (e sono tutti vettori lunghi tanto quanto il vettore dei dati originali):

```{r}
set.seed(1)
R <- 50000
data <- runif(100, 1, 10)

data.b <- boot(
  data,
  statistic = function(x, i) mean(x[i]),
  R = R
)
```

È come dire che se abbiamo il campione 

```{r}
(v <- rnorm(5))
```

i campioni di bootstrap li generiamo a partire da una lista di sequenze casuali di indici:

```{r}
index <- list(
  sample(1:5, 5, replace=T),
  sample(1:5, 5, replace=T),
  sample(1:5, 5, replace=T),
  sample(1:5, 5, replace=T)
)
```

a cui corrispondono i campioni di bootstrap:

```{r}
list(
  v[index[[1]]],
  v[index[[2]]],
  v[index[[3]]],
  v[index[[4]]] 
)
```
e le corrispettive stime:

```{r}
list(
  mean(v[index[[1]]]),
  mean(v[index[[2]]]),
  mean(v[index[[3]]]),
  mean(v[index[[4]]])
)
```

Quanto sopra per $R=4$. Se vogliamo realizzare migliaia di campioni di bootstrap o automatizziamo questa procedura (ad es. usando le funzioni `map`, e questo può essere un valido esercizio), oppure usiamo la funzione `boot`, che chiama appunto la funzione passata all'argomento `statistic` applicandola al vettore dei dati (nell'esempio: `v`) e passando di volta in volta un nuovo vettore di indici (nell'esempio: `index[i]`).

Ora `data.b` contiene le informazioni di bootstrap. In particolare, è possibile usare la funzione `boot.ci` per calcolare i limiti dell'intervallo di confidenza (qui confrontato con quello calcolato con il `t.test`):

```{r}
(data.ci <- boot.ci(data.b, conf=0.95, type="perc"))
(data.tt <- t.test(data))
```

Si noti che l'oggetto restituito da `boot.ci` contiene il campo `$percent`, che è un vettore di 5 elementi. Secondo quanto dichiarato dall'help in linea, gli ultimi due elementi sono gli estremi dell'intervallo. Confrontiamoli graficamente con quelli calcolati secondo Student:

```{r}
data.orig <- tibble(
  i = seq_along(data) * 500,
  y = data
)

tibble(
  i = 1:R,
  t = data.b$t
) %>% 
  ggplot(aes(x=i, y=t)) + 
  geom_point(size=0.5) +
  geom_point(data=data.orig, aes(x=i, y=y), color=gray(0.5)) +
  geom_hline(yintercept=data.tt$conf.int[1], color="red") +
  geom_hline(yintercept=data.tt$conf.int[2], color="red") +
  geom_hline(yintercept=data.ci$percent[4], color="green", linetype=2) +
  geom_hline(yintercept=data.ci$percent[5], color="green", linetype=2)
```

**Esercizio**: trasfromare l'ultimo grafico in un istogramma con le linee verticali che rappresentano l'intervallo di confidenza.